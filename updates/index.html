<!DOCTYPE html><html lang="de" data-critters-container=""><head prefix="og: http://ogp.me/ns# book: http://ogp.me/ns/book#"><meta name="generator" content="Scully 0.0.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">

  <title>Angular-Buch → Angular 17 ist da!</title>
  

  

  <meta property="book:author" content="https://www.facebook.com/ferdinand.malcher">
  <meta property="book:author" content="https://www.facebook.com/johannes.hoppe">

  <meta property="book:isbn" content="9783864909467">
  <meta property="book:release_date" content="2023-02-28">
  <meta property="book:tag" content="Angular">
  <meta property="book:tag" content="Webentwicklung">
  <meta property="book:tag" content="AngularJS">
  <meta property="book:tag" content="TypeScript">
  <meta property="book:tag" content="JavaScript">
  <meta property="book:tag" content="HTML5">
  <meta property="book:tag" content="CSS">
  <meta property="book:tag" content="RxJS">
  <meta property="book:tag" content="Redux">
  <meta property="book:tag" content="NgRx">

  <base href="/">
<style>@font-face{font-family:Roboto;src:url(Roboto-Thin.3025beb410a67d09.eot);src:local("Roboto Thin"),local("Roboto-Thin"),url(Roboto-Thin.3025beb410a67d09.eot?#iefix) format("embedded-opentype"),url(Roboto-Thin.a529f43f8b43a41b.woff2) format("woff2"),url(Roboto-Thin.0cfb6189823d7275.woff) format("woff"),url(Roboto-Thin.94d67324d95f59e5.ttf) format("truetype"),url(Roboto-Thin.761d85cbad1d4c0a.svg#Roboto) format("svg");font-weight:100;font-style:normal}@font-face{font-family:Roboto;src:url(Roboto-ThinItalic.3c0494ed5066eddf.eot);src:local("Roboto ThinItalic"),local("Roboto-ThinItalic"),url(Roboto-ThinItalic.3c0494ed5066eddf.eot?#iefix) format("embedded-opentype"),url(Roboto-ThinItalic.7d4425d4f9dfbd4d.woff2) format("woff2"),url(Roboto-ThinItalic.72445820525e265f.woff) format("woff"),url(Roboto-ThinItalic.72ab0263ccb0dc3f.ttf) format("truetype"),url(Roboto-ThinItalic.7d3f4f17bca5edb0.svg#Roboto) format("svg");font-weight:100;font-style:italic}@font-face{font-family:Roboto;src:url(Roboto-Light.9cff5f27f6ad3d59.eot);src:local("Roboto Light"),local("Roboto-Light"),url(Roboto-Light.9cff5f27f6ad3d59.eot?#iefix) format("embedded-opentype"),url(Roboto-Light.7117d83fbb0aa28a.woff2) format("woff2"),url(Roboto-Light.2188ea3f3f8ab51a.woff) format("woff"),url(Roboto-Light.5605865fb101be1a.ttf) format("truetype"),url(Roboto-Light.775a1d8f32378e56.svg#Roboto) format("svg");font-weight:300;font-style:normal}@font-face{font-family:Roboto;src:url(Roboto-LightItalic.4a75ae9969c094a3.eot);src:local("Roboto LightItalic"),local("Roboto-LightItalic"),url(Roboto-LightItalic.4a75ae9969c094a3.eot?#iefix) format("embedded-opentype"),url(Roboto-LightItalic.9669ba38989190d7.woff2) format("woff2"),url(Roboto-LightItalic.ead2698c38e2d858.woff) format("woff"),url(Roboto-LightItalic.ccdc52ada30d970f.ttf) format("truetype"),url(Roboto-LightItalic.293a6c412ebb5682.svg#Roboto) format("svg");font-weight:300;font-style:italic}@font-face{font-family:Roboto;src:url(Roboto-Regular.b21a0eefbec4f57f.eot);src:local("Roboto Regular"),local("Roboto-Regular"),url(Roboto-Regular.b21a0eefbec4f57f.eot?#iefix) format("embedded-opentype"),url(Roboto-Regular.e64b7e5db276537f.woff2) format("woff2"),url(Roboto-Regular.2313f68c10458709.woff) format("woff"),url(Roboto-Regular.b796ce65a81adc41.ttf) format("truetype"),url(Roboto-Regular.18c20975d2f2578c.svg#Roboto) format("svg");font-weight:400;font-style:normal}@font-face{font-family:Roboto;src:url(Roboto-RegularItalic.e6e0d5b40d74c833.eot);src:local("Roboto RegularItalic"),local("Roboto-RegularItalic"),url(Roboto-RegularItalic.e6e0d5b40d74c833.eot?#iefix) format("embedded-opentype"),url(Roboto-RegularItalic.d448549043fc24e3.woff2) format("woff2"),url(Roboto-RegularItalic.6c93c3855305929c.woff) format("woff"),url(Roboto-RegularItalic.c6469a92f47f72b9.ttf) format("truetype"),url(Roboto-RegularItalic.f83754e74962d444.svg#Roboto) format("svg");font-weight:400;font-style:italic}@font-face{font-family:Roboto;src:url(Roboto-Medium.9a9c9421bcdef79c.eot);src:local("Roboto Medium"),local("Roboto-Medium"),url(Roboto-Medium.9a9c9421bcdef79c.eot?#iefix) format("embedded-opentype"),url(Roboto-Medium.31c42d9dbee477e5.woff2) format("woff2"),url(Roboto-Medium.769ea541b3eef14d.woff) format("woff"),url(Roboto-Medium.03501557d620ee6b.ttf) format("truetype"),url(Roboto-Medium.8a59a67632175b0b.svg#Roboto) format("svg");font-weight:500;font-style:normal}@font-face{font-family:Roboto;src:url(Roboto-MediumItalic.eda8bf9be9c607a9.eot);src:local("Roboto MediumItalic"),local("Roboto-MediumItalic"),url(Roboto-MediumItalic.eda8bf9be9c607a9.eot?#iefix) format("embedded-opentype"),url(Roboto-MediumItalic.2b1343b2d0b09b92.woff2) format("woff2"),url(Roboto-MediumItalic.226e2a5000081685.woff) format("woff"),url(Roboto-MediumItalic.ce75fe30feef2519.ttf) format("truetype"),url(Roboto-MediumItalic.b51310a741b5d779.svg#Roboto) format("svg");font-weight:500;font-style:italic}@font-face{font-family:Roboto;src:url(Roboto-Bold.0d2870f5e1759c7a.eot);src:local("Roboto Bold"),local("Roboto-Bold"),url(Roboto-Bold.0d2870f5e1759c7a.eot?#iefix) format("embedded-opentype"),url(Roboto-Bold.6980f6575e8c2cbd.woff2) format("woff2"),url(Roboto-Bold.313d5de65a92aae6.woff) format("woff"),url(Roboto-Bold.ed694f411e0b3a82.ttf) format("truetype"),url(Roboto-Bold.a5d983d959171823.svg#Roboto) format("svg");font-weight:700;font-style:normal}@font-face{font-family:Roboto;src:url(Roboto-BoldItalic.24d4fc9379818f4d.eot);src:local("Roboto BoldItalic"),local("Roboto-BoldItalic"),url(Roboto-BoldItalic.24d4fc9379818f4d.eot?#iefix) format("embedded-opentype"),url(Roboto-BoldItalic.986a9dba772d1a7a.woff2) format("woff2"),url(Roboto-BoldItalic.d0b1358f293918c7.woff) format("woff"),url(Roboto-BoldItalic.e3188bd071401a05.ttf) format("truetype"),url(Roboto-BoldItalic.98e79b0548caa896.svg#Roboto) format("svg");font-weight:700;font-style:italic}@font-face{font-family:Roboto;src:url(Roboto-Black.2a430d2577a70997.eot);src:local("Roboto Black"),local("Roboto-Black"),url(Roboto-Black.2a430d2577a70997.eot?#iefix) format("embedded-opentype"),url(Roboto-Black.710dab121b2a7bc2.woff2) format("woff2"),url(Roboto-Black.06740b883cfa8a2e.woff) format("woff"),url(Roboto-Black.41a719429c37346e.ttf) format("truetype"),url(Roboto-Black.711c7acb0aa346bb.svg#Roboto) format("svg");font-weight:900;font-style:normal}@font-face{font-family:Roboto;src:url(Roboto-BlackItalic.65db2fd69db01cd5.eot);src:local("Roboto BlackItalic"),local("Roboto-BlackItalic"),url(Roboto-BlackItalic.65db2fd69db01cd5.eot?#iefix) format("embedded-opentype"),url(Roboto-BlackItalic.f4307ac32c9ad43b.woff2) format("woff2"),url(Roboto-BlackItalic.fc1832915de70c44.woff) format("woff"),url(Roboto-BlackItalic.ba2ec768f43dbc84.ttf) format("truetype"),url(Roboto-BlackItalic.26186c8936090567.svg#Roboto) format("svg");font-weight:900;font-style:italic}@charset "UTF-8";:root{--blue:#007bff;--indigo:#6610f2;--purple:#6f42c1;--pink:#e83e8c;--red:#dc3545;--orange:#fd7e14;--yellow:#ffc107;--green:#28a745;--teal:#20c997;--cyan:#17a2b8;--white:#fff;--gray:#6c757d;--gray-dark:#343a40;--primary:#007bff;--secondary:#6c757d;--success:#28a745;--info:#17a2b8;--warning:#ffc107;--danger:#dc3545;--light:#f8f9fa;--dark:#343a40;--breakpoint-xs:0;--breakpoint-sm:576px;--breakpoint-md:768px;--breakpoint-lg:992px;--breakpoint-xl:1200px;--font-family-sans-serif:-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";--font-family-monospace:SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}*,*:before,*:after{box-sizing:border-box}html{font-family:sans-serif;line-height:1.15;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:rgba(0,0,0,0)}body{margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,Liberation Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;text-align:left;background-color:#fff}img{vertical-align:middle;border-style:none}svg{overflow:hidden;vertical-align:middle}@media print{*,*:before,*:after{text-shadow:none!important;box-shadow:none!important}img{page-break-inside:avoid}@page{size:a3}body{min-width:992px!important}}body{color:#1e1e1e;font-family:"Roboto","Helvetica Neue",Helvetica,Arial sans-serif;font-size:16px;line-height:1.35em;font-weight:400;background:#F8F8F8}html{overflow-y:scroll}</style><link rel="stylesheet" href="styles.d4c7874ddc2b97aa.css" media="all" onload="this.media='all'"><noscript><link rel="stylesheet" href="styles.d4c7874ddc2b97aa.css"></noscript><meta property="og:title" content="Angular-Buch → Angular 17 ist da!"><meta name="twitter:title" content="Angular-Buch → Angular 17 ist da!"><meta name="description" content="📙 In diesem Artikel berichten wir über Angular in Version 17. Die finale Veröffentlichung auf NPM ist für Mittwoch, den 8. November 2023, angekündigt. Sie können bereits jetzt alle Neuigkeiten bei uns erfahren. Die gezeigten Befehle und Einstellungen werden jedoch erst mit der offiziellen Veröffentlichung funktionieren."><meta property="og:description" content="📙 In diesem Artikel berichten wir über Angular in Version 17. Die finale Veröffentlichung auf NPM ist für Mittwoch, den 8. November 2023, angekündigt. Sie können bereits jetzt alle Neuigkeiten bei uns erfahren. Die gezeigten Befehle und Einstellungen werden jedoch erst mit der offiziellen Veröffentlichung funktionieren."><meta name="twitter:description" content="📙 In diesem Artikel berichten wir über Angular in Version 17. Die finale Veröffentlichung auf NPM ist für Mittwoch, den 8. November 2023, angekündigt. Sie können bereits jetzt alle Neuigkeiten bei uns erfahren. Die gezeigten Befehle und Einstellungen werden jedoch erst mit der offiziellen Veröffentlichung funktionieren."><meta name="twitter:site" content="@angular_buch"><meta property="og:locale" content="de"><meta property="og:type" content="website"><meta property="og:url" content="https://angular-buch.com/blog/2023-11-angular17"><style>.width-6{width:6.5rem}.width-8{width:8rem}.linkImage{margin-right:3px;margin-top:-3px}
</style><style>.content img{max-width:100%}.details-page-autor{margin-top:-110px}.details-thumbnail{margin-bottom:-18px}.details-thumbnail .details-thumbnail-inner{border-bottom:23px solid #dfdede;max-height:300px;overflow:hidden;background-color:#fff;border-radius:4px;display:flex;justify-content:center}.details-thumbnail .details-thumbnail-inner .darken-overlay{display:block;position:absolute;height:300px;width:100%;padding-left:15px;padding-right:15px;padding-bottom:23px}.details-thumbnail .details-thumbnail-inner .darken-overlay div{display:block;position:relative;width:100%;height:100%;background-color:#0003;border-radius:4px 4px 0 0/4px 4px 0px 0px}.details-thumbnail img{width:100%;align-self:center}.video-container{position:relative;padding-bottom:56.25%;padding-top:0;height:0;overflow:hidden;margin-top:2rem;margin-bottom:2rem}.video-container iframe,.video-container object,.video-container embed{position:absolute;top:0;left:0;width:100%;height:100%}
</style><style>a[_ngcontent-ng-c3500202515]:link, a[_ngcontent-ng-c3500202515]:visited{text-decoration:underline}a[_ngcontent-ng-c3500202515]:hover, a[_ngcontent-ng-c3500202515]:active{text-decoration:none}</style><meta property="og:image" content="https://website-articles.angular-buch.com/blog/2023-11-angular17/angular17.jpg"><meta name="twitter:image" content="https://website-articles.angular-buch.com/blog/2023-11-angular17/angular17.jpg"><meta name="twitter:card" content="summary_large_image"><script>window['ScullyIO']='generated';</script></head>
<body scully-version="0.0.0">
  <app-root ng-version="16.2.7"><header><div class="nav__overlay"></div><div class="container"><div class="row no-gutters align-items-center"><div class="col-6 col-md-2"><a routerlink="/" aria-label="Startseite" href="/"><img src="assets/img/brand-400.png" alt="Angular-Buch.com" height="40" width="126" class="img-fluid"></a></div><div class="col-6 col-md-10"><nav><ul><li><app-link><!----><!----><!----><a routerlinkactive="nav__current" ariacurrentwhenactive="page" href="/"><!----> Buch </a><!----><!----><!----></app-link></li><li><app-link><!----><!----><a routerlinkactive="nav__current" ariacurrentwhenactive="page" href="/blog" class="nav__current" aria-current="page"><!----> Blog </a><!----><!----><!----><!----></app-link></li><li><app-link><!----><!----><a routerlinkactive="nav__current" ariacurrentwhenactive="page" href="/material"><!----> Begleitmaterial </a><!----><!----><!----><!----></app-link></li><li><app-link><!----><!----><a routerlinkactive="nav__current" ariacurrentwhenactive="page" href="/kaufen"><img alt="" class="linkImage ls-is-cached lazyloaded" data-src="assets/img/symbol-basket.svg" src="assets/img/symbol-basket.svg"><!----> Jetzt kaufen </a><!----><!----><!----><!----></app-link></li><li><app-link><!----><a class="order" href="//angular.schule/"><img alt="" class="linkImage ls-is-cached lazyloaded" data-src="assets/img/symbol-group.svg" src="assets/img/symbol-group.svg"><!----> Schulungen </a><!----><!----><!----><!----><!----></app-link></li><!----></ul></nav><a href="/" aria-label="Navigation" class="nav__toggle"><img src="assets/img/symbol-menu.svg" alt=""></a></div></div></div></header><main><router-outlet></router-outlet><app-blog-details><app-hero-header headline="Blog" headlinelink="/blog"><section class="hero hero--smaller"><div class="hero__lines"><div class="container"><div class="row justify-content-between"><div class="col-md-6 col-xs-12"><h1 class="headline__page headline__page--blank headline__page--space-bottom"><a style="color: white;" href="/blog">Blog</a><!----><!----></h1></div></div></div></div></section><a name="content" id="content"></a></app-hero-header><section class="index index--list blog mt-n5"><div class="index__stripe index__stripe--list"><!----><div class="container"><a name="post" id="post"></a><div class="row details-thumbnail"><div class="col-12"><div class="details-thumbnail-inner"><img alt="" class="img-fluid rounded lazyloaded" data-src="https://website-articles.angular-buch.com/blog/2023-11-angular17/angular17.jpg" src="https://website-articles.angular-buch.com/blog/2023-11-angular17/angular17.jpg"><!----></div></div><!----></div><div class="row"><div class="col-12"><div class="index__item index__item--list"><div class="row align-items-top"><div class="col-12 col-sm-3 col-md-2 text-center details-page-autor"><img alt="" class="blog__portrait img-fluid rounded-circle ls-is-cached lazyloaded" data-src="//www.gravatar.com/avatar/be546eb804b80c7e8c1ac0fc082b5463?size=200&amp;rating=pg&amp;d=mm" src="//www.gravatar.com/avatar/be546eb804b80c7e8c1ac0fc082b5463?size=200&amp;rating=pg&amp;d=mm"><span class="blog__author">Angular Buch Team <br><a target="_blank" class="twitter" href="https://twitter.com/angular_buch"> @angular_buch</a> &nbsp; <!----><!----></span></div><div class="col-12 col-sm-9 col-md-10 col-lg-10"><h1 class="blog__headline">Angular 17 ist da!</h1><p class="blog__date">06.11.2023</p><p class="content markdown-body"><blockquote>
<p><strong>In diesem Artikel berichten wir über Angular in Version 17. Die finale Veröffentlichung auf NPM ist für Mittwoch, den 8. November 2023, angekündigt. Sie können bereits jetzt alle Neuigkeiten bei uns erfahren. Die gezeigten Befehle und Einstellungen werden jedoch erst mit der offiziellen Veröffentlichung funktionieren.</strong></p>
</blockquote>
<p>Es ist wieder ein halbes Jahr vorbei: Anfang November 2023 erschien die neue Major-Version <strong>Angular 17</strong>!
Angular-Teammitglied Minko Gechev hatte diese Version schon vor einigen Wochen als sein <a href="https://twitter.com/mgechev/status/1681375250335039488">"favorite Angular release … ever"</a> beschrieben.</p>
<p>Auch wir sind der Meinung: Die Community wurde nicht enttäuscht! Die wichtigsten Neuigkeiten zu Angular 17 fassen wir in diesem Blogpost zusammen.</p>
<!-- Im offiziellen [Angular-Blog](https://blog.angular.io/introducing-angular-v17-a03dada02150) finden Sie alle Informationen des Angular-Teams.
Außerdem empfehlen wir Ihnen einen Blick in die Changelogs von [Angular](https://github.com/angular/angular/blob/main/CHANGELOG.md) und der [Angular CLI](https://github.com/angular/angular-cli/blob/main/CHANGELOG.md).-->



<h2 id="angulardev-das-neue-gesicht-von-angular">angular.dev: Das neue Gesicht von Angular</h2>
<p>Angular hat ein neues Logo! Seit 6. November erstrahlt das große A unseres Lieblingsframeworks mit einem modernen Farbverlauf.
Die viel größere Neuigkeit verbirgt sich aber hinter der neuen Domain <strong><a href="https://angular.dev">angular.dev</a></strong>: Hier finden Sie ab sofort die neue Landingpage und Dokumentation von Angular.
Die Inhalte wurden vollständig überarbeitet, um vor allem den Einstieg in das Framework zu vereinfachen.
Die Dokumentation setzt zum großen Teil auf die neuen Konzeprte wie Signals und den neuen Control Flow.</p>
<p>Die offizielle Ankündigung des Angular-Teams finden Sie im <a href="https://blog.angular.io/announcing-angular-dev-1e1205fa3039">Angular-Blog</a>.</p>
<h3 id="angular-im-wandel-der-zeit">Angular im Wandel der Zeit</h3>
<p>Das bisherige Angular-Logo ist weithin bekannt: Das weiße A auf einem roten Schild ist <em>das</em> Identifikationsmerkmal von Angular.
Gleichzeitig schaut das Logo auf eine lange Geschichte zurück: Die erste Version wurde ab 2012 mit dem Vorgänger-Framework "AngularJS" bekannt.
Im September 2016 wurde das neue Framework "Angular" veröffentlicht, das eine vollständige Neuentwicklung war – Name und Logo blieben jedoch grundlegend erhalten.</p>
<p>In den letzten Jahren hat Angular eine starke Entwicklung durchgemacht. Standalone Components, Signals, Control Flow, funktionale Guards/Interceptoren und Typed Reactive Forms sind nur eine Auswahl der neuen Strömungen.
Gelegentlich hören wir das Feedback, Angular sei "tot" oder werde "nicht mehr weiterentwickelt".
Doch das Gegenteil ist der Fall: Angular wird allein innerhalb des Konzerns Google in über 1.200 Anwendungen produktiv eingesetzt. Es ist eins der führenden Frameworks, um Webanwendungen für den Enterprise-Bereich zu entwickeln und kann auf einer Stufe mit anderen großen Frameworks wie Vue.js oder React stehen.</p>
<p>Um diesen frischen Wind nicht nur auf technischer Ebene sichtbar zu machen, präsentiert sich Angular seit Version 17 mit einem neuen Logo und einem neuen Portal für Entwicklerinnen und Entwickler.
Seit Version 2.0 im September 2016 hat sich in Angular viel getan – und wir freuen uns, dass dieser "Renaissance" nun ein neues Gesicht verliehen wurde.</p>
<div style="margin: auto">
  <img src="https://website-articles.angular-buch.com/blog/2023-11-angular17/logo-history.png" alt="Geschichte des Logos">
  <p><small>Das Angular-Logo im Wandel der Zeiten: AngularJS (2012), Angular (2016), Angular (2023)</small></p>
</div>



<h2 id="projekt-updaten">Projekt updaten</h2>
<p>Wenn Sie mit unserem Angular-Buch das Beispielprojekt <em>BookMonkey</em> entwickeln, sind keine Anpassungen am Code notwendig.
Die Inhalte des Buchs sind auch mit Angular 17 noch aktuell.</p>
<p>Um ein existierendes Projekt zu aktualisieren, nutzen Sie bitte den <a href="https://update.angular.io/?v=16.0-17.0">Angular Update Guide</a>.
Der Befehl <code>ng update</code> liefert außerdem Informationen zu möglichen Updates direkt im Projekt.</p>
<pre><code class="language-bash"><span class="hljs-meta"># Projekt auf Angular 17 aktualisieren</span>
ng update <span class="hljs-symbol">@angular</span>/core<span class="hljs-symbol">@17</span> <span class="hljs-symbol">@angular</span>/cli<span class="hljs-symbol">@17</span>
</code></pre>
<p>Dadurch werden nicht nur die Pakete aktualisiert, sondern auch notwendige Migrationen im Code durchgeführt.
Prüfen Sie danach am Besten mithilfe der Differenzansicht von Git die Änderungen.</p>
<p>Unabhängig von den Inhalten unseres Buchs besteht grundsätzlich immer die Möglichkeit, die neuen Features von Angular auch im <em>BookMonkey</em> zu nutzen.
Probieren Sie doch zum Beispiel einmal den neuen Control Flow aus – dazu gleich mehr!</p>
<h2 id="unterstützte-versionen-von-typescript-und-nodejs">Unterstützte Versionen von TypeScript und Node.js</h2>
<p>Um Angular 17 zu nutzen, sind die folgenden Versionen von TypeScript und Node.js notwendig:</p>
<ul>
<li><strong>TypeScript 5.2</strong>. Der Support für TypeScript-Versionen kleiner als 5.2 wurde eingestellt.</li>
<li><strong>Node.js 18.13.0</strong>. Node.js in Version 16 wird nicht mehr unterstützt.</li>
</ul>
<h2 id="signals-gelten-als-stable">Signals gelten als stable</h2>
<p>Mit Angular 16 wurde das Konzept der Signals eingeführt. 
Im Blogpost <em><a href="/blog/2023-05-angular16">Angular 16 ist da!</a></em> haben wir die Ideen dieser neuen <em>Reactive Primitive</em> genauer beschrieben.
Die Signals-Bibliothek von Angular gilt nun als <em>stable</em>, sodass Signals auch in produktiven Anwendungen genutzt werden können.</p>
<p>Die Reise mit Signals ist damit aber noch nicht vorbei: In den nächsten Monaten werden weitere Neuerungen kommen, vor allem im Blick auf vollständig signal-basierte Komponenten (<a href="https://github.com/angular/angular/discussions/49682">siehe RFC auf GitHub</a>).
Damit wird es möglich sein, Angular-Anwendungen "zoneless" zu betreiben, also ohne die Bibliothek zone.js.
Dieses Hilfsmittel ist seit jeher notwendig, um die Change Detection von Angular zu triggern – der Prozess, der Änderungen an den Daten ermittelt und die Views der Anwendung automatisch aktualisiert.
Um diesen Ablauf gezielter und performanter durchzuführen, sind Signals ein wichtiger Grundbaustein.</p>
<p>Übrigens: Die Signal-Methode <code>mutate()</code> ist in diesem Release nicht mehr enthalten.
Die Hintergründe sind im zugehörigen <a href="https://github.com/angular/angular/commit/c7ff9dff2c14aba70e92b9e216a2d4d97d6ef71e">Commit auf GitHub</a> ausgeführt.
Statt <code>mutate()</code> muss also die Methode <code>update()</code> verwendet werden. Dabei müssen Arrays und Objekte als <em>immutable</em> behandelt werden.</p>
<h2 id="neuer-control-flow-if-for-switch">Neuer Control Flow: <code>@if</code>, <code>@for</code>, <code>@switch</code></h2>
<p>Die bekannten Strukturdirektiven <code>NgIf</code>, <code>NgFor</code> und <code>NgSwitch</code> sind in ihrer Funktionsweise stark abhängig von zone.js.
Auf dem Weg zu "Zoneless Angular Apps" musste das Angular-Team das Konzept dieser Direktiven überdenken.</p>
<p>Mit Angular 17 ist nun der neue <em>Control Flow</em> für Templates verfügbar!
Damit wird die Funktionalität der bekannten Direktiven direkt in die Template-Syntax integriert.
Diese Neuerung hat auch bei der Entwicklung einen entscheidenen Vorteil: Die Syntax wird vom Compiler ausgewertet, und es ist nicht mehr notwendig, die Direktiven (oder das <code>CommonModule</code>) zu importieren, damit sie überhaupt in der Komponente genutzt werden können.</p>
<p>Die Ausdrücke für den neuen Control Flow werden direkt im HTML-Code notiert und mit einem <code>@</code>-Symbol eingeleitet.
Um Konflikte mit den neuen Steuerzeichen der Template-Syntax zu vermeiden (<code>@</code> und geschweifte Klammern), müssen diese Zeichen manuell escapet werden, wenn sie anderweitig im HTML-Code genutzt werden.
Beim automatischen Update auf Angular 17 wird dieser Schritt automatisch vorgenommen.</p>
<p>Wenn Sie die neue Syntax verwenden wollen, stellen Sie bitte sicher, dass Sie den <em>Angular Language Service</em> in Visual Studio Code installiert haben. Diese Extension sorgt für korrektes Syntax Highlighting in den Templates.
Die IDEs der Firma Jetbrains können auch bereits mit der Syntax umgehen.</p>
<h3 id="bedingungen-mit-if">Bedingungen mit <code>@if</code></h3>
<p>Der <code>@if</code>-Block dient dazu, bestimmte Teile eines HTML-Templates nur dann anzuzeigen, wenn eine Bedingung erfüllt ist.
Er ersetzt die Direktive <code>*ngIf</code>.
Im <code>@if</code>-Block steht eine Bedingung. Nur wenn diese Bedingung wahr ist, wird der Teil des Templates gezeigt.</p>
<p>Ein <code>@if</code>-Block kann auch <code>@else</code>-Blöcke enthalten: Das sind alternative Zweige, die angezeigt werden, wenn die Bedingung im <code>@if</code>-Teil nicht erfüllt ist.
Man kann einen einfachen <code>@else</code>-Block definieren, der immer dann zum Einsatz kommt, wenn die <code>@if</code>-Bedingung nicht zutrifft – oder man kann zusätzliche <code>@else</code>-Blöcke mit weiteren Bedingungen definieren:</p>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- VORHER --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"books?.length &gt; 1; else elseBlock"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">book-list</span> [<span class="hljs-attr">books</span>]=<span class="hljs-string">"books"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> #<span class="hljs-attr">elseBlock</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"books?.length === 1; else elseBlock2"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">book-details</span> [<span class="hljs-attr">book</span>]=<span class="hljs-string">"books[0]"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> #<span class="hljs-attr">elseBlock2</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Keine Bücher verfügbar!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    
<span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span>
</code></pre>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- NACHHER --&gt;</span>
@if (books?.length &gt; 1) {
  <span class="hljs-tag">&lt;<span class="hljs-name">book-list</span> [<span class="hljs-attr">books</span>]=<span class="hljs-string">"books"</span> /&gt;</span>
} @else if (books?.length === 1) {
  <span class="hljs-tag">&lt;<span class="hljs-name">book-details</span> [<span class="hljs-attr">book</span>]=<span class="hljs-string">"books[0]"</span> /&gt;</span>
} @else {
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Keine Bücher verfügbar!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
}
</code></pre>
<p>Es fällt sofort auf, dass der <code>@else</code>-Zweig deutlich einfacher zu definieren ist als zuvor. Der Einsatz von <code>&lt;ng-template&gt;</code> ist nicht mehr notwendig!
Außerdem war es bislang häufig erforderlich, das spezielle Tag <code>&lt;ng-container&gt;</code> einzusetzen, um mehrere Elemente zu gruppieren, ohne ein unnötiges DOM-Element zu erzeugen.
Auch dies entfällt mit der neuen Syntax, da die Gruppierung nun über die Klammern geschieht.</p>
<h3 id="wiederholungen-mit-for">Wiederholungen mit <code>@for</code></h3>
<p>Der Schleifenblock <code>@for</code> ersetzt <code>*ngFor</code> für Iterationen und unterscheidet sich in einigen Punkten von der bislang eingesetzten Direktive:</p>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- VORHER --&gt;</span> 
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"book of books"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">book-list-item</span> [<span class="hljs-attr">book</span>]=<span class="hljs-string">"book"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"!books.length"</span>&gt;</span>Keine Bücher verfügbar!<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- NACHHER --&gt;</span> 
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
  @for (book of books; track book.isbn) {
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">book-list-item</span> [<span class="hljs-attr">book</span>]=<span class="hljs-string">"book"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  } @empty {
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Keine Bücher verfügbar!<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  }
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<p>Es ist nun möglich, einen <code>@empty</code>-Block anzugeben, der aktiv wird, wenn es keine Einträge gibt. Dies war zuvor nicht direkt möglich.
Die gezeigte Option <code>track</code> ersetzt das Konzept der <code>trackBy</code>-Funktion: Sie bestimmt für jede Zeile den Schlüssel, der intern verwendet wird, um Array-Elemente eindeutig zu identifizieren. Bei der Direktive <code>*ngFor</code> war es optional, das explizite Tracking zu verwenden. Mit der neuen Syntax ist <code>track</code> jedoch eine Pflichtangabe.</p>
<p>Eine weitere Vereinfachung besteht darin, dass die Hilfsvariablen nicht mehr extra deklariert werden müssen – sie sind nun direkt innerhalb des Blocks verfügbar.</p>
<pre><code class="language-html"><span class="xml"><span class="hljs-comment">&lt;!-- VORHER --&gt;</span> 
<span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"book of books; index as i"</span>&gt;</span>
  </span><span class="hljs-template-variable">{{ <span class="hljs-name">i</span> + <span class="hljs-number">1</span> }}</span><span class="xml">. Buch: <span class="hljs-tag">&lt;<span class="hljs-name">book-list-item</span> [<span class="hljs-attr">book</span>]=<span class="hljs-string">"book"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</code></pre>
<pre><code class="language-html"><span class="xml"><span class="hljs-comment">&lt;!-- NACHHER --&gt;</span> 
@for (book of books; track book.isbn) {
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
    </span><span class="hljs-template-variable">{{ <span class="hljs-name">$index</span> + <span class="hljs-number">1</span> }}</span><span class="xml">. Buch: <span class="hljs-tag">&lt;<span class="hljs-name">book-list-item</span> [<span class="hljs-attr">book</span>]=<span class="hljs-string">"book"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
}</span>
</code></pre>
<p>Falls das iterierte Array nur primitive Werte (z. B. Strings) beinhaltet, wird für das Tracking übrigens der Wert selbst als Identifikator verwendet:</p>
<pre><code class="language-html"><span class="xml">@for (name of nameList; track name) {
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><span class="hljs-template-variable">{{ <span class="hljs-name">name</span> }}</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
}</span>
</code></pre>
<p>Folgende Hilfsvariablen stehen in einem <code>@for</code>-Block zur Verfügung:</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Bedeutung</th>
</tr>
</thead>
<tbody><tr>
<td><code>$index</code></td>
<td>Index der aktuellen Zeile</td>
</tr>
<tr>
<td><code>$first</code></td>
<td>gibt an, ob die aktuelle Zeile die erste ist</td>
</tr>
<tr>
<td><code>$last</code></td>
<td>gibt an, ob die aktuelle Zeile die letzte ist</td>
</tr>
<tr>
<td><code>$even</code></td>
<td>gibt an, ob der Index der aktuellen Zeile gerade ist</td>
</tr>
<tr>
<td><code>$odd</code></td>
<td>gibt an, ob der Index der aktuellen Zeile ungerade ist</td>
</tr>
</tbody></table>
<h3 id="fallunterscheidungen-mit-switch">Fallunterscheidungen mit <code>@switch</code></h3>
<p>Auch die Direktive <code>NgSwitch</code> erhält einen Nachfolger. Die neue Syntax mit <code>@switch</code> ist nun deutlich ähnlicher zum <code>switch</code>-Statement in JavaScript als zuvor:</p>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- VORHER --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> [<span class="hljs-attr">ngSwitch</span>]=<span class="hljs-string">"bedingung"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> *<span class="hljs-attr">ngSwitchCase</span>=<span class="hljs-string">"1"</span>&gt;</span>Ansicht für Fall 1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> *<span class="hljs-attr">ngSwitchCase</span>=<span class="hljs-string">"2"</span>&gt;</span>Ansicht für Fall 2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> *<span class="hljs-attr">ngSwitchCase</span>=<span class="hljs-string">"3"</span>&gt;</span>Ansicht für Fall 3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> *<span class="hljs-attr">ngSwitchDefault</span>&gt;</span>Standardansicht, wenn kein anderer Fall zutrifft<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>
</code></pre>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- NACHHER --&gt;</span>
@switch (bedingung) {
  @case (1) {
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Ansicht für Fall 1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  }
  @case (2) {
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Ansicht für Fall 2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  }
  @case (3) {
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Ansicht für Fall 3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  }
  @default {
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Standardansicht, wenn kein anderer Fall zutrifft<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  }
}
</code></pre>
<h3 id="was-passiert-mit-den-direktiven">Was passiert mit den Direktiven?</h3>
<p>Die bisherigen Direktiven bleiben zunächst erhalten und können parallel zum Control Flow verwendet werden.
Sie müssen Ihre Anwendungen also nicht sofort migrieren, sondern können auch weiterhin den gewohnten Ablauf mit den Direktiven nutzen.
Ebenso ist ein Mischbetrieb möglich, sodass z. B. neue Features sofort mit dem neuen Control Flow ausgestattet werden können.</p>
<p>Grundsätzlich empfehlen wir Ihnen jedoch, in den nächsten Monaten schrittweise zur neuen Control-Flow-Syntax zu migrieren.
Es ist abzusehen, dass die Direktiven <code>NgIf</code>, <code>NgFor</code> und <code>NgSwitch</code> in einer zukünftigen Major-Version als <em>deprecated</em> markiert werden.</p>
<p>Angular stellt übrigens ein Skript bereit, um die Templates auf den neuen Control Flow zu migrieren:</p>
<pre><code class="language-bash">ng <span class="hljs-keyword">generate</span> @angular/core:control-flow
</code></pre>
<p>Bitte beachten Sie, dass die Migration nicht vollständig automatisch funktioniert.
Die Ergebnisse müssen stets manuell geprüft und nachgebessert werden.
In unseren ersten Experimenten war die Automigration hilfreich, hat aber nicht alle Fälle korrekt erfasst.</p>
<h2 id="deferrable-views-mit-defer">Deferrable Views mit <code>@defer</code></h2>
<!-- siehe https://github.com/angular/angular/discussions/50716 -->

<p>Mit dem neuen Control Flow wird ein sehr nützliches neues Feature eingeführt: der <code>@defer</code>-Block.
Wir können damit Teile von HTML-Templates verzögert nachladen.</p>
<p>Dabei ist es egal, ob es sich um reines HTML, eine Komponente, eine Direktive, eine Pipe oder ein komplexeres Template handelt – wenn HTML-Inhalte in einem solchen Block platziert werden, lädt Angular diese Inhalte nur unter bestimmten Bedingungen oder bei bestimmten Ereignissen zur Laufzeit nach.
Das ist besonders nützlich, um die Leistung zu optimieren, insbesondere wenn bestimmte Komponenten nicht sofort benötigt werden oder für die anwendende Person noch gar nicht sichtbar sind.</p>
<p>Grundsätzlich ermöglicht der Router mithilfe von Lazy Loading bereits, ganze Seiten zur Laufzeit nachzuladen. Mit Deferrable Views wird dieses Konzept jetzt noch differenzierter einsetzbar: Wir behandeln nicht nur ganze Seiten, sondern nach Bedarf auch kleinere Teile ihrer Templates.</p>
<pre><code class="language-html"><span class="hljs-params">&lt;p&gt;</span>Dieser folgende Teil des Templates wird später geladen!<span class="hljs-params">&lt;/p&gt;</span>

@<span class="hljs-class">defer </span>{
  <span class="hljs-params">&lt;book-details [book]="myBook" /&gt;</span>
}
@<span class="hljs-class">loading </span>{
  <span class="hljs-params">&lt;span&gt;</span>Inhalte werden geladen …<span class="hljs-params">&lt;/span&gt;</span>
} @<span class="hljs-class">placeholder </span>{
  <span class="hljs-params">&lt;span&gt;</span>Inhalt wurde noch nicht geladen.<span class="hljs-params">&lt;/span&gt;</span>
} @<span class="hljs-class">error </span>{
  <span class="hljs-params">&lt;span&gt;</span>Es kam zu einem Fehler!<span class="hljs-params">&lt;/span&gt;</span>
}
</code></pre>
<p>Folgende Hilfsblöcke stehen gemeinsam mit <code>@defer</code> zur Verfügung:</p>
<ul>
<li><code>@placeholder</code>: Zeigt den angegebenen Inhalt als Platzhalter, bevor der eigentliche Inhalt geladen wurde. Der Platzhalter muss in den meisten Fällen angegeben werden! </li>
<li><code>@loading</code>: Zeigt den angegebenen Inhalt an, <em>während</em> die Abhängigkeiten geladen werden, also nachdem der Ladevorgang gestartet wurde. Die Inhalte von <code>@loading</code> ersetzen den Placeholder!</li>
<li><code>@error</code>: Zeigt den angegebenen Inhalt an, falls ein Problem beim Laden des Inhalts auftritt.</li>
</ul>
<p>Statten wir also einen <code>@defer</code>-Block mit <code>@placeholder</code> und <code>@loading</code> aus, so ist zunächst der Placeholder zu sehen.
Sobald das Laden der Inhalte durchgeführt wird, wird der <code>@loading</code>-Block angezeigt.
Ist das Laden abgeschlossen, sind die Inhalte sichtbar.</p>
<p>Standardmäßig wird der Inhalt eines <code>@defer</code>-Blocks sofort geladen, nachdem die Anwendung fertig gerendert wurde.
Um das Verhalten genauer zu steuern, steht eine Sammlung von Triggern zu Verfügung.
Sie steuern, wann Angular den Inhalt laden und rendern soll.</p>
<h3 id="loading-trigger-on-viewport">Loading Trigger: <code>on viewport</code></h3>
<p>Der Inhalt wird nachgeladen, wenn der Placeholder sichtbar wird, also in den Viewport des Browsers rückt:</p>
<pre><code class="language-html"><span class="hljs-keyword">@defer</span> (on viewport) {
  &lt;<span class="hljs-selector-tag">p</span>&gt;Dieser Inhalt wird später geladen!&lt;/<span class="hljs-selector-tag">p</span>&gt;
}
<span class="hljs-keyword">@placeholder</span> {
  &lt;<span class="hljs-selector-tag">p</span>&gt;Inhalt wurde noch nicht geladen …&lt;/<span class="hljs-selector-tag">p</span>&gt;
}
</code></pre>
<h3 id="loading-trigger-on-timer">Loading Trigger: <code>on timer</code></h3>
<p>Der Inhalt wird nachgeladen, wenn der angegebene Timer abgelaufen ist:</p>
<pre><code class="language-html"><span class="hljs-keyword">@defer</span> (on timer(<span class="hljs-number">3s</span>)) {
  &lt;<span class="hljs-selector-tag">p</span>&gt;Dieser Inhalt wird erst nach <span class="hljs-number">3</span> Sekunden geladen!&lt;/<span class="hljs-selector-tag">p</span>&gt;
}
<span class="hljs-keyword">@placeholder</span> {
  &lt;<span class="hljs-selector-tag">p</span>&gt;Inhalt wurde noch nicht geladen …&lt;/<span class="hljs-selector-tag">p</span>&gt;
}
</code></pre>
<h3 id="loading-trigger-when">Loading Trigger: <code>when</code></h3>
<p>Der Inhalt wird nachgeladen, wenn die angegebene Bedingung erfüllt ist:</p>
<pre><code class="language-html"><span class="hljs-keyword">@defer</span> (when myDeferFlag) {
  &lt;<span class="hljs-selector-tag">p</span>&gt;Dieser Inhalt wird einmalig geladen, wenn `myDeferFlag` wahr ist!&lt;/<span class="hljs-selector-tag">p</span>&gt;
}
<span class="hljs-keyword">@placeholder</span> {
  &lt;<span class="hljs-selector-tag">p</span>&gt;Inhalt wurde noch nicht geladen …&lt;/<span class="hljs-selector-tag">p</span>&gt;
}
</code></pre>
<h2 id="routing-mit-view-transition-api">Routing mit View Transition API</h2>
<p>Der Router von Angular unterstützt nun die native <a href="https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API">View Transition API</a>.
Damit ist es möglich, animierte Übergänge im DOM beim Wechsel zwischen Routen zu implementieren.
Bitte beachten Sie, dass die Schnittstelle noch nicht in allen Browsern unterstützt wird.</p>
<p>Um das neue Feature zu nutzen, verwenden wir die Funktion <code>withViewTransitions()</code> in der Konfiguration des Routers:</p>
<pre><code class="language-ts"><span class="hljs-regexp">//</span> app.config.ts
import { provideRouter, withViewTransitions } from <span class="hljs-string">'@angular/router'</span>;

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(
      [<span class="hljs-regexp">/* ... */</span>], <span class="hljs-regexp">//</span> Routen
      withViewTransitions() <span class="hljs-regexp">//</span> View Transitions aktivieren
    ),
  ],
});
</code></pre>
<p>Damit der Effekt sichtbar wird, müssen wir außerdem eine passende Animation implementieren.
Dafür werden die CSS-Pseudo-Selektoren <code>::view-transition-old</code> und <code>::view-transition-new</code> verwendet:</p>
<pre><code class="language-css"><span class="hljs-keyword">@keyframes</span> slide-right {
  <span class="hljs-selector-tag">from</span> {
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">100px</span>);
  }
}

<span class="hljs-keyword">@keyframes</span> slide-left {
  <span class="hljs-selector-tag">to</span> {
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">100px</span>);
  }
}

::<span class="hljs-built_in">view-transition-old</span>(root) {
  animation: <span class="hljs-number">500ms</span> linear both slide-left;
}

::<span class="hljs-built_in">view-transition-new</span>(root) {
  animation: <span class="hljs-number">500ms</span> linear both slide-right;
}
</code></pre>
<p>Anstatt der Angabe <code>root</code> können wir hier auch einen anderen CSS-Selektor angeben, auf den die View Transition angewandt werden soll.
Mit dem Wert <code>root</code> erfolgt die Transition auf dem gesamten Dokument.</p>
<h2 id="neuerungen-bei-server-side-rendering">Neuerungen bei Server-Side Rendering</h2>
<p>Das Angular-Team hat im neuesten Release stark an dem Support für Server-Side-Rendering (SSR) gearbeitet.
Das bisherige Projekt <em>Angular Universal</em> wurde dafür direkt in den Core von Angular aufgenommen. Es wird ab sofort unter dem neuen Namen <code>@angular/ssr</code> veröffentlicht.</p>
<p>Mithilfe von Server-Side Rendering kann die Angular-Anwendung bereits auf dem Server ausgeführt werden, sodass der Aufbau des DOM-Baums nicht mehr vollständig im Browser passieren muss.
Das kann für eine bessere wahrgenommene Start-Performance sorgen, weil beim ersten Laden der Seite bereits grundlegender Inhalt sichtbar ist, auch bevor Angular die Seite gerendert hat.
Richtig eingesetzt kann SSR bessere Ergebnisse bei den Core Web Vitals ermöglichen.
Außerdem ist SSR ein elementarer Baustein für Suchmaschinenoptimierung.</p>
<p>Angular hat hier bei der sogenannten <em>Partial Hydration</em> nachgebessert:
Nach der ersten Auslieferung der server-gerenderten Anwendung wird im Browser nicht mehr die gesamte Anwendung neu gerendert und ersetzt.
Stattdessen werden nur die relevanten (interaktiven) Teile der Anwendung ermittelt, und nur diese werden mithilfe von JavaScript <em>hydriert</em>, also zum dynamischen Leben erweckt.
Dieses Konzept wurde grundlegend bereits mit Angular 16 eingeführt.</p>
<p>Die wichtigste Neuigkeit ist, dass wir beim Anlegen unseres Projekts mit <code>ng new</code> sofort den Support für SSR aktivieren können:</p>
<pre><code class="language-bash">ng <span class="hljs-keyword">new</span> book-monkey <span class="hljs-comment">--ssr</span>
</code></pre>
<p>Wollen wir in einem bestehenden Projekt nachträglich SSR aktivieren, können wir den folgenden Befehl nutzen:</p>
<pre><code class="language-bash">ng <span class="hljs-keyword">add</span> <span class="hljs-title">@angular</span>/ssr
</code></pre>
<p>Dabei wird der neue Application Builder eingesetzt, den wir im nächsten Abschnitt vorstellen.</p>
<h2 id="application-builder-auf-basis-von-esbuild">Application Builder auf Basis von ESBuild</h2>
<!-- Quelle: https://github.com/angular/angular/pull/52407/files -->

<p>Mit Angular 16 wurde ein neues Build-System auf Basis von <a href="https://esbuild.github.io/">ESBuild</a> als <em>Developer Preview</em> vorgestellt. ESBuild kann vor allem mit einer deutlich besseren Performance aufwarten als das alte System. Dank vieler Verbesserungen und positiver Rückmeldungen aus der Community fühlt sich das Angular-Team nun sicher genug, den Builder in Angular 17 als stabil zu erklären.</p>
<blockquote>
<p>ℹ️ <strong>Was ist ein Builder?</strong> Jedes Mal, wenn wir einen Befehl wie <code>ng build</code>, <code>ng serve</code> oder <code>ng test</code> starten, wird im Hintergrund ein <em>Builder</em> ausgeführt. Es handelt sich also um das Skript, das den Build-Prozess durchführt. Der verwendete Builder wird in der Datei <code>angular.json</code> konfiguriert.</p>
</blockquote>
<h3 id="für-neue-projekte">Für neue Projekte</h3>
<p>Der ESBuild-basierte Build wird nun für alle Applikationen, die mit <code>ng new</code> bzw. <code>npm create</code> erstellt werden, automatisch aktiv sein. 
Dafür ist in der Datei <code>angular.json</code> der Builder mit dem Namen <code>@angular-devkit/build-angular:application</code> voreingestellt.</p>
<h3 id="für-bestehende-projekte">Für bestehende Projekte</h3>
<p>Das bestehende Build-System auf Basis von Webpack gilt weiterhin als stabil und wird vollständig unterstützt. Bestehende Projekte können den bisherigen Builder weiterhin nutzen und werden bei einem Update nicht automatisch umgestellt.
Um die Vorteile des neuen Build-Systems zu nutzen, können Sie die Datei <code>angular.json</code> wie folgt anpassen:</p>
<pre><code class="language-json">{
  <span class="hljs-comment">// VORHER</span>
  <span class="hljs-attr">"architect"</span>: {
    <span class="hljs-attr">"build"</span>: {
      <span class="hljs-attr">"builder"</span>: <span class="hljs-string">"@angular-devkit/build-angular:browser"</span>,
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  <span class="hljs-comment">// NACHHER</span>
  <span class="hljs-attr">"architect"</span>: {
    <span class="hljs-attr">"build"</span>: {
      <span class="hljs-attr">"builder"</span>: <span class="hljs-string">"@angular-devkit/build-angular:browser-esbuild"</span>,
    }
  }
}
</code></pre>
<p>Weitergehende Änderungen sind nicht notwendig, um das neue Build-System zu nutzen.
Der neue Builder <code>browser-esbuild</code> dient als direkte Alternative ("drop-in replacement") zum bestehenden <code>browser</code>-Builder.
Wollen Sie Server-Side Rendering nutzen, ist in dieser Konfiguration weiterhin der bestehende Builder für Angular Universal erforderlich.</p>
<h3 id="der-neue-application-builder">Der neue <code>application</code>-Builder</h3>
<p>Um die Landschaft der verschiedenen Builder-Skripte zu vereinheitlichen, wurde mit Angular 17 ein neuer Builder <code>application</code> eingeführt.
Für neue Projekte ist dieser Builder automatisch voreingestellt, sodass Sie nichts weiter tun müssen.
Auch für bestehende Projekte empfehlen wir, auf den <code>application</code>-Builder zu wechseln.</p>
<p>Der neue Builder vereint alle Aufgaben, die zuvor in verschiedenen Buildern untergebracht waren: Server-Side Rendering und Pre-Rendering stehen nun direkt zur Verfügung, ohne dass wir dafür separate Builder installieren müssen.</p>
<pre><code class="language-json">{
  <span class="hljs-comment">// VORHER</span>
  <span class="hljs-string">"architect"</span>: {
    <span class="hljs-string">"build"</span>: {
      <span class="hljs-string">"builder"</span>: <span class="hljs-string">"@angular-devkit/build-angular:browser"</span>,
      <span class="hljs-string">"options: {</span>
        <span class="hljs-comment">// ...</span>
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  <span class="hljs-comment">// NACHHER</span>
  <span class="hljs-string">"architect"</span>: {
    <span class="hljs-string">"build"</span>: {
      <span class="hljs-string">"builder"</span>: <span class="hljs-string">"@angular-devkit/build-angular:application"</span>,
      <span class="hljs-string">"options: {</span>
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Optionen müssen aktualisiert werden</span>
      }
    }
  }
}
</code></pre>
<p>Da es sich um einen vollständig neuen Builder handelt, müssen Sie einige Optionen in der Datei <code>angular.json</code> anpassen.
Nachdem Sie den Namen des Builders auf <code>application</code> geändert haben, aktualisieren Sie bitte die folgenden Einträge unter <code>options</code>:</p>
<ol>
<li>Die Option <code>main</code> sollten Sie in <code>browser</code> umbenennen.</li>
<li>Bei <code>polyfills</code> sollten Sie den Wert in ein Array umwandeln, falls dies nicht bereits geschehen ist.</li>
<li>Die Optionen <code>buildOptimizer</code>, <code>resourcesOutputPath</code>, <code>vendorChunk</code>, <code>commonChunk</code>, <code>deployUrl</code> und <code>ngswConfigPath</code> können Sie entfernen. </li>
<li>Den Wert von <code>ngswConfigPath</code> sollten Sie allerdings zu <code>serviceWorker</code> verschieben und dann die Option entfernen. <code>serviceWorker</code> ist jetzt entweder <code>false</code> oder ein Konfigurationspfad.</li>
</ol>
<p>Wenn Ihre Anwendung kein Server-Side-Rendering (SSR) verwendet, sind dies alle Änderungen, die Sie vornehmen müssen, damit <code>ng build</code> wie gewohnt funktioniert.
Es ist möglich, dass dennoch Fehler oder Warnungen auftreten, wenn Ihre Anwendung spezifische Webpack-Features nutzt.
Sollte es unerwartete Verhaltensunterschiede zwischen den Buildern geben, bittet das Angular-Team darum, ein <a href="https://github.com/angular/angular-cli/issues">Issue auf GitHub</a> zu eröffnen.</p>
<p>Für Anwendungen, die bereits SSR (mit und ohne Pre-Rendering) verwenden, sind zusätzliche manuelle Anpassungen erforderlich.
Der neue <code>application</code>-Builder übernimmt nun die Funktionalitäten aller bisherigen Builder <code>prerender</code>, <code>server</code>, <code>ssr-dev-server</code> und <code>app-shell</code>.
Die jeweiligen Optionen müssen deshalb gemeinsam an den <code>application</code>-Builder übergeben werden.</p>
<p>Wir begrüßen sehr, dass diese große Auwahl an Buildern für unterschiedliche Zwecke endlich vereinheitlicht wird.
Bitte konsultieren Sie den <a href="https://angular.dev/guide/ssr">SSR Guide</a> bzw. <a href="https://angular.dev/guide/prerendering">Prerendering Guide</a> in der offiziellen Dokumentation für eine ausführliche Beschreibung der notwendigen Schritte.</p>
<h2 id="sonstiges">Sonstiges</h2>
<p>Neben den großen Features hat Angular eine Menge von kleineren Neuerungen und Bugfixes an Bord.
Einige interessante Punkte haben wir hier aufgeführt:</p>
<ul>
<li>Die <code>styleUrls</code> in den Metadaten einer Komponente mussten seit jeher als Array notiert werden. Da häufig nur eine einzige Style-URL angegeben wird, können wir dort nun auch einen einfachen String angeben: <code>styleUrls: './my.component.scss'</code>.</li>
<li>Die Option <code>--routing</code> ist beim Erzeugen eines neuen Workspace mit <code>ng new</code> bzw. <code>npm create</code> nun standardmäßig aktiviert.</li>
<li>Die Option <code>--standalone</code> ist beim Erzeugen eines neuen Workspace mit <code>ng new</code> bzw. <code>npm create</code> nun standardmäßig aktiviert – es werden also keine Angular-Module (<code>@NgModule()</code>) mehr erzeugt. </li>
<li>Animationen mit <code>@angular/animations</code> können lazy geladen werden, sodass die Implementierung nicht mehr sofort zusammen mit der Hauptanwendung geladen werden muss, siehe <a href="https://github.com/angular/angular/commit/e753278faae79a53e235e0d8e03f89555a712d80">Commit</a>.</li>
</ul>
<hr>


<p>Wir wünschen Ihnen viel Spaß mit Angular 17!
Haben Sie Fragen zur neuen Version zu Angular oder zu unserem Buch? Schreiben Sie uns!</p>
<p><strong>Viel Spaß wünschen
Ferdinand, Danny und Johannes</strong></p>
<hr>

<p><small><strong>Titelbild:</strong> Raukenlandschaft, Fårö/Gotland, Schweden. Foto von Ferdinand Malcher</small></p>
</p><!----><!----><a routerlink="/blog" ripple-radius="" class="btn btn-sm btn-primary mt-4" href="/blog"><i class="fa fa-backward mr-2"></i> Zurück</a><hr> Suggestions? Feedback? Bugs? Please <a target="_blank" class="content" href="https://github.com/angular-buch/website-articles/blob/gh-pages/blog/2023-11-angular17/README.md"><i class="fa fa-github mr-1" style="font-size: 1.6rem; position: relative; bottom: -3px;"></i>fork/edit this page on Github</a>. </div></div></div></div></div><!----></div><!----></div></section><app-json-ld><script type="application/ld+json">{
  "url": "https://angular.schule/blog/2023-11-angular17",
  "headline": "Angular 17 ist da!",
  "description": "In diesem Artikel berichten wir über Angular in Version 17. Die finale Veröffentlichung auf NPM ist für Mittwoch, den 8. November 2023, angekündigt. Sie können bereits jetzt alle Neuigkeiten bei uns erfahren. Die gezeigten Befehle und Einstellungen werden jedoch erst mit der offiziellen Veröffentlichung funktionieren.",
  "datePublished": "2023-11-06",
  "dateModified": "2023-11-06",
  "publisher": {
    "name": "Angular-Buch",
    "url": "https://angular-buch.com",
    "@type": "Organization",
    "logo": {
      "@type": "ImageObject",
      "url": "https://angular-buch.com/assets/img/brand_export.png"
    }
  },
  "image": "https://website-articles.angular-buch.com/blog/2023-11-angular17/angular17.jpg",
  "thumbnailUrl": "https://website-articles.angular-buch.com/blog/2023-11-angular17/angular17.jpg",
  "author": {
    "@type": "Person",
    "name": "Angular Buch Team",
    "email": "team@angular-buch.com"
  },
  "keywords": [
    "Angular",
    "Angular 17",
    "Signals",
    "Control Flow",
    "Deferrable Views",
    "View Transition API",
    "ESBuild",
    "Logo",
    "angular.dev"
  ],
  "mainEntityOfPage": "http://schema.org/WebPage",
  "@type": "Article",
  "@context": "http://schema.org"
}</script></app-json-ld></app-blog-details><!----><footer><div class="container"><div class="row align-items-center"><div class="col-sm-9"><div class="links"><app-link><!----><!----><!----><a routerlinkactive="nav__current" ariacurrentwhenactive="page" class="links__item" href="/"><!----> Home </a><!----><!----><!----></app-link>|<!----><!----><!----><app-link><!----><!----><a routerlinkactive="nav__current" ariacurrentwhenactive="page" class="links__item" href="/impressum"><!----> Impressum </a><!----><!----><!----><!----></app-link>|<!----><!----><!----><app-link><!----><!----><a routerlinkactive="nav__current" ariacurrentwhenactive="page" class="links__item" href="/datenschutz"><!----> Datenschutzerklärung </a><!----><!----><!----><!----></app-link>|<!----><!----><!----><app-link><!----><a class="links__item links__twitter" href="https://twitter.com/angular_buch" rel="nofollow"><!----> Twitter </a><!----><!----><!----><!----><!----></app-link><!----><!----><!----></div></div><div class="col-sm-3 text-right"></div></div></div></footer></main><app-json-ld><script type="application/ld+json"></script></app-json-ld></app-root>
<script src="runtime.c2a94130f78adc69.js" type="module"></script><script src="polyfills.2d45871e56172284.js" type="module"></script><script src="main.f1902d17af4fe40a.js" type="module"></script>

</body></html>